"use strict";(self.webpackChunksynalinks_website=self.webpackChunksynalinks_website||[]).push([[407],{3468:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>s,default:()=>m,frontMatter:()=>i,metadata:()=>a,toc:()=>l});var r=n(4848),o=n(8453);const i={sidebar_position:4},s="Fact Memory",a={id:"api/hybridstores/fact-memory",title:"Fact Memory",description:"HybridAGI triplet store",source:"@site/docs/api/hybridstores/fact-memory.md",sourceDirName:"api/hybridstores",slug:"/api/hybridstores/fact-memory",permalink:"/documentation/docs/api/hybridstores/fact-memory",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:4,frontMatter:{sidebar_position:4},sidebar:"apiSidebar",previous:{title:"Trace Memory",permalink:"/documentation/docs/api/hybridstores/trace-memory"},next:{title:"Knowledge Parsers",permalink:"/documentation/docs/category/knowledge-parsers"}},d={},l=[{value:"HybridAGI triplet store",id:"hybridagi-triplet-store",level:2},{value:"Usage",id:"usage",level:2}];function c(e){const t={code:"code",h1:"h1",h2:"h2",img:"img",p:"p",pre:"pre",...(0,o.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.h1,{id:"fact-memory",children:"Fact Memory"}),"\n",(0,r.jsx)(t.h2,{id:"hybridagi-triplet-store",children:"HybridAGI triplet store"}),"\n",(0,r.jsx)(t.p,{children:"The Fact Memory allows the agent system to access a knowledge graph representing entities and their relations, enabling GraphRAGs and other knowledge-intensive applications. By indexing the entities, it enables the agent to search for a specific entity to answer questions or to verify facts."}),"\n",(0,r.jsx)(t.p,{children:"This data structure is classical in knowledge-based systems like in robotics, biology or medecine. However, there is one drawback: the knowledge graphs are domain-specific, so the structure will vary significantly depending on your application. We provide some knowledge parsers to help you leverage this, but you will likely have to implement your own knowledge parser depending on your application."}),"\n",(0,r.jsx)("figure",{children:(0,r.jsx)("p",{align:"center",children:(0,r.jsxs)(t.p,{children:[(0,r.jsx)(t.img,{alt:"HybridAGI fact memory",src:n(1306).A+"",width:"530",height:"521"}),"\n",(0,r.jsx)("figcaption",{align:"center",children:(0,r.jsx)("b",{children:"Fig.1 - HybridAGI's fact memory indexes each entity, allowing graph augmented generation."})})]})})}),"\n",(0,r.jsx)(t.h2,{id:"usage",children:"Usage"}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-python",children:'from hybridagi import ProgramMemory, FactMemory\nfrom hybridagi import SentenceTransformerEmbeddings\nfrom hybridagi.tools import (\n    EntitySearch, # allows the system to search for entities\n)\n\nembeddings = SentenceTransformerEmbeddings(\n    dim = 384,\n    model_name_or_path = "sentence-transformers/all-MiniLM-L6-v2",\n)\n\nprogram_memory = ProgramMemory(\n    index_name = "hybrid_agi", \n    embeddings = embeddings,\n)\n\nfact_memory = FactMemory(\n    index_name = "hybrid_agi", # The global index\n    embeddings = embeddings, # The embeddings to use\n    graph_index = "fact_memory", # The hybridstore index (default to fact_memory)\n    hostname = "localhost", # FalkorDB hostname (default to localhost)\n    port = 6379, # FalkorDB port (default to 6379)\n    username = "", # FalkorDB username (empty by default)\n    password = "", # FalkorDB password (empty by default)\n    indexed_label = "Entity", # The label of the indexed nodes (default to Entity)\n    wipe_on_start = False, # Whether or not to wipe the hybridstore at start (default to False)\n)\n\ntools = [\n    EntitySearch(\n        fact_memory = fact_memory\n    ),\n]\n\ninterpreter = GraphProgramInterpreter(\n    program_memory = program_memory,\n    tools = tools,\n)\n'})})]})}function m(e={}){const{wrapper:t}={...(0,o.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(c,{...e})}):c(e)}},1306:(e,t,n)=>{n.d(t,{A:()=>r});const r=n.p+"assets/images/fact_memory-af8f0e308d61f5b00879f37eb76fa774.png"},8453:(e,t,n)=>{n.d(t,{R:()=>s,x:()=>a});var r=n(6540);const o={},i=r.createContext(o);function s(e){const t=r.useContext(i);return r.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),r.createElement(i.Provider,{value:t},e.children)}}}]);