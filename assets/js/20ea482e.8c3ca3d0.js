"use strict";(self.webpackChunksynalinks_website=self.webpackChunksynalinks_website||[]).push([[252],{7448:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>p,contentTitle:()=>r,default:()=>d,frontMatter:()=>i,metadata:()=>a,toc:()=>l});var o=n(4848),s=n(8453);const i={},r="Custom Tools",a={id:"api/tools/custom-tools",title:"Custom Tools",description:"In HybridAGI, each tool is a module that is optimized in the background when the interpreter calls it during optimization. Each tool is a DSPy module that is optimized in the background when the interpreter calls it during optimization.",source:"@site/docs/api/tools/custom-tools.md",sourceDirName:"api/tools",slug:"/api/tools/custom-tools",permalink:"/documentation/docs/api/tools/custom-tools",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"apiSidebar",previous:{title:"Available Tools",permalink:"/documentation/docs/api/tools/available-tools"}},p={},l=[];function c(e){const t={code:"code",h1:"h1",p:"p",pre:"pre",...(0,s.R)(),...e.components};return(0,o.jsxs)(o.Fragment,{children:[(0,o.jsx)(t.h1,{id:"custom-tools",children:"Custom Tools"}),"\n",(0,o.jsx)(t.p,{children:"In HybridAGI, each tool is a module that is optimized in the background when the interpreter calls it during optimization. Each tool is a DSPy module that is optimized in the background when the interpreter calls it during optimization."}),"\n",(0,o.jsx)(t.p,{children:"To add a new tool to HybridAGI, there are two ways to do it. The first way is easier, while the other gives you more control but involves more code."}),"\n",(0,o.jsx)(t.p,{children:"Let's see the easiest way first:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-python",children:'\ndef greet(**kwargs):\n    """\n    This function greets the person passed in as a parameter\n    """\n    name = kwargs["name"] # The function inputs need to use python **kwargs\n    # Here goes your tool logic\n    message = f"Hello, {name}. Nice to meet you!"\n    print(message)\n    # You have then to returns the output of your function as a dict\n    output = {}\n    output["message"] = message\n    return output\n\nmy_custom_tool = Tool(\n    name = "Greet", # The name of the tool\n    signature = "name -> message", # The function signature (multi input/output are possible like in DSPy signature)\n    instructions = "Greet a person", # The tool instruction\n    func = greet, # And the callable function\n    lm = my_lm # You can optionally use another LM to infer the inputs of the tool\n)\n\n'})}),"\n",(0,o.jsxs)(t.p,{children:["The other way to create a custom tool gives you better control, for that you have to create an object that inherit from ",(0,o.jsx)(t.code,{children:"BaseTool"}),":"]}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-python",children:"import abc\nimport dspy\nfrom typing import Optional\n\nclass BaseTool(dspy.Module):\n\n    def __init__(self, name: str):\n        self.name = name\n\n    @abc.abstractmethod\n    def forward(\n            self,\n            trace: str,\n            objective: str,\n            purpose: str,\n            prompt: str,\n            disable_inference: bool = False,\n            llm: Optional[dspy.LM] = None\n        ) -> dspy.Prediction:\n        pass\n"})}),"\n",(0,o.jsx)(t.p,{children:"Here is the same example with the second method:"}),"\n",(0,o.jsx)(t.pre,{children:(0,o.jsx)(t.code,{className:"language-python",children:'\nimport dspy\nfrom typing import Optional\nfrom hybridagi.tools import BaseTool\nfrom hybridagi.output_parsers.prediction import PredictionOutputParser\n\ndef greet(name):\n    """\n    This function greets the person passed in as a parameter\n    """\n    message = f"Hello, {name}. Nice to meet you!"\n    print(message)\n    return message\n\nclass GreetSignature(dspy.Signature):\n    """You will be given an objective, purpose and context\n    Using the prompt to help you, you will infer the correct name"""\n    objective = dspy.InputField(desc = "The long-term objective (what you are doing)")\n    context = dspy.InputField(desc = "The previous actions (what you have done)")\n    purpose = dspy.InputField(desc = "The purpose of the action (what you have to do now)")\n    prompt = dspy.InputField(desc = "The action specific instructions (How to do it)")\n    name = dspy.OutputField(desc = "The name of the person to greet")\n\nclass GreetTool(BaseTool):\n\n    def __init__(\n            self,\n            lm = Optional[dspy.LM] = None,\n        ):\n        super().__init__(name = "Greet")\n        self.predict = dspy.Predict(GreetSignature)\n        self.prediction_parser = PredictionOutputParser()\n    \n    def forward(\n            self,\n            context: str,\n            objective: str,\n            purpose: str,\n            prompt: str,\n            disable_inference: bool = False,\n        ) -> dspy.Prediction:\n        """Method to perform DSPy forward prediction"""\n        if not disable_inference:\n            # Perform a DSPy prediction\n            with dspy.context(lm=self.lm if self.lm is not None else dspy.settings.lm):\n                # This allow the tool to use a different LM than the one you configured in DSPy\n                # Allowing you to choose the best LM to infer the tool inputs\n                pred = self.predict(\n                    objective = objective,\n                    context = context,\n                    purpose = purpose,\n                    prompt = prompt,\n                )\n            # Some parsing to clean up the prediction\n            pred.name = self.prediction_parser.parse(pred.name, prefix = "Name:", stop = ["\\n"])\n            # Then we can call our python function\n            message = greet(pred.name)\n            # The tool always returns a dspy.Prediction with the tools\'s input and output to give to the system the \n            # possibility to enhance its reasoning by calling a tool multiple times.\n            return dspy.Prediction(\n                name = pred.answer\n                message = message\n            )\n        else:\n            # When disabling inference, we use the prompt given in the graph program as input\n            message = self.greet(prompt)\n            return dspy.Prediction(\n                answer = prompt\n                message = message\n            )\n\nmy_custom_tool = GreetTool()\n'})})]})}function d(e={}){const{wrapper:t}={...(0,s.R)(),...e.components};return t?(0,o.jsx)(t,{...e,children:(0,o.jsx)(c,{...e})}):c(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>a});var o=n(6540);const s={},i=o.createContext(s);function r(e){const t=o.useContext(i);return o.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function a(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:r(e.components),o.createElement(i.Provider,{value:t},e.children)}}}]);