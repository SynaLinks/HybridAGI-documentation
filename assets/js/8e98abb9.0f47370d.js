"use strict";(self.webpackChunkdocumentation=self.webpackChunkdocumentation||[]).push([[357],{9337:(e,n,i)=>{i.r(n),i.d(n,{assets:()=>c,contentTitle:()=>s,default:()=>d,frontMatter:()=>r,metadata:()=>a,toc:()=>h});var t=i(5893),o=i(1151);const r={sidebar_position:2},s="Graph Prompt Programming",a={id:"basics/graph-prompt-programming",title:"Graph Prompt Programming",description:"Learn how to program HybridAGI",source:"@site/docs/basics/graph-prompt-programming.md",sourceDirName:"basics",slug:"/basics/graph-prompt-programming",permalink:"/SynaLinks/basics/graph-prompt-programming",draft:!1,unlisted:!1,tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2},sidebar:"tutorialSidebar",previous:{title:"Neuro-Symbolic AI Systems",permalink:"/SynaLinks/basics/neuro-symbolic"},next:{title:"Actions as Tool",permalink:"/SynaLinks/basics/actions-as-tool"}},c={},h=[{value:"Introducing Graph-based Prompt Programming",id:"introducing-graph-based-prompt-programming",level:3},{value:"Your first graph-based prompt program",id:"your-first-graph-based-prompt-program",level:2},{value:"Leveraging explicit decision making steps",id:"leveraging-explicit-decision-making-steps",level:2}];function l(e){const n={a:"a",admonition:"admonition",code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,o.a)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"graph-prompt-programming",children:"Graph Prompt Programming"}),"\n",(0,t.jsx)(n.p,{children:"Learn how to program HybridAGI"}),"\n",(0,t.jsx)(n.h3,{id:"introducing-graph-based-prompt-programming",children:"Introducing Graph-based Prompt Programming"}),"\n",(0,t.jsx)(n.p,{children:"Graph-based Prompt Programming is the foundation of our technology. In this approach, a program is represented as a property graph, which consists of four key types of nodes, each serving a unique purpose:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Action Nodes"}),": Action nodes represent specific actions. These nodes are responsible for the use of a tool within the program. Each action node contains the name of the tool used, the purpose of the action and a description of how to infer the tool's input parameters."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Decision Nodes"}),": Decision nodes are used to make choices within the program. These nodes have outgoing edges that branch off to different paths or actions based on certain conditions or criteria. The labels on the outgoing edges of decision nodes specify the possible answers. These labels guide the flow of the program to different branches, creating a decision graph."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Control Nodes"}),": Control nodes help define the program's overall structure and execution flow. The Start Node marks the beginning of the program's execution. It doesn't perform an action but acts as an entry point. The End Node marks the conclusion or termination of the program. It doesn't perform an action but acts as an exit point."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.strong,{children:"Program Nodes"}),": These nodes represent the call to a subprogram. When the program flow reaches a program node, it jumps to the designated program's graph, executes it, and then returns to the calling program."]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"This formulation enables you to create complex programs by connecting nodes with edges and specifying logical conditions using labels on those edges."}),"\n",(0,t.jsx)(n.h2,{id:"your-first-graph-based-prompt-program",children:"Your first graph-based prompt program"}),"\n",(0,t.jsxs)(n.p,{children:["Now, let's dive into the practical aspect of graph-based prompt programming with your first program. In this example, you will learn the fundamental elements of creating a program using ",(0,t.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Cypher_(query_language)",children:"Cypher"}),", a powerful and expressive language used in graph databases."]}),"\n",(0,t.jsx)(n.admonition,{title:"How to name your nodes?",type:"tip",children:(0,t.jsx)(n.p,{children:"The names of each node gives the purpose of the step to the system, and each node inside a sub-program need a unique name. If you need two or more nodes with the same name/purpose, you probably need a loop instead."})}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",metastring:'title="hello_world.cypher"',children:'CREATE\n// Nodes declaration\n(start:Control {name:"Start"}), // The entrypoint\n(end:Control {name:"End"}), // The endpoint\n(hello_world:Action {\n    name:"Say hello to the User",\n    tool:"Speak",\n    prompt:"Say hello world in French"}),\n// Structure declaration\n(start)-[:NEXT]->(hello_world),\n(hello_world)-[:NEXT]->(end)\n'})}),"\n",(0,t.jsx)(n.p,{children:'In the provided Cypher code snippet, a simple program called "hello_world" is created. Let\'s break down what this program does:'}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"CREATE"}),": This statement initializes the creation of a program graph."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:'(start:Control {name:"Start"})'}),": This line defines the Start Node, which acts as the entry point of your program. It doesn't perform an action but signifies where the program execution begins."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:'(end:Control {name:"End"})'}),": The End Node is defined here. It marks the conclusion or termination point of the program, where the program execution ends."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:'(hello_world:Action {name:"Say hello to the User", tool:"Speak", prompt:"Say hello world in French"})'}),': This line creates an Action Node named "hello_world." It represents a specific action, in this case, saying "Hello World in French" to the user. The tool attribute specifies the tool or function used to execute this action, which is "Speak" in this case.']}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"(start)-[:NEXT]->(hello_world)"}),': This line creates a relationship between the Start Node and the "hello_world" Action Node. The ',(0,t.jsx)(n.code,{children:"[:NEXT]"}),' relationship signifies the program\'s flow, indicating that the execution should proceed from the Start Node to the "hello_world" Action Node.']}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"(hello_world)-[:NEXT]->(end)"}),': Here, a similar relationship is established between the "hello_world" Action Node and the End Node, indicating that after executing the action, the program should terminate.']}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:'So, when you run this program, it starts at the Start Node, moves to the "hello_world" Action Node, which performs the action of saying "Hello World in French" and then proceeds to the End Node, completing the program.'}),"\n",(0,t.jsx)(n.h2,{id:"leveraging-explicit-decision-making-steps",children:"Leveraging explicit decision making steps"}),"\n",(0,t.jsx)(n.p,{children:"One of the particularity of our framework is the explicit decision making steps allowing the system to branch over the graph. This feature make decisions made by the LLM explicit, thus more explainable."}),"\n",(0,t.jsx)(n.p,{children:'In the provided Cypher "clarify_objective" program, we are introducing explicit decision-making steps to allow the system to branch over the graph. This feature makes the decisions made by the LLM explicit, enhancing the program\'s explainability.'}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",metastring:'title="clarify_objective.cypher"',children:'CREATE\n// Nodes declaration\n(start:Control {name:"Start"}),\n(end:Control {name:"End"}),\n(is_anything_unclear:Decision {\n    name:"Find out if there is anything unclear in the Objective", \n    question:"Is the Objective unclear?"}),\n(ask_question:Action {\n    name:"Ask question to clarify the objective",\n    tool:"AskUser",\n    prompt:"Pick one question to clarify the Objective"}),\n(refine_objective:Action {\n    name:"Clarify the given objective",\n    tool:"UpdateObjective", \n    prompt:"The refined Objective"}),\n// Structure declaration\n(start)-[:NEXT]->(is_anything_unclear),\n(ask_question)-[:NEXT]->(refine_objective),\n(refine_objective)-[:NEXT]->(is_anything_unclear)\n// The outgoing edges of decision nodes give\n// the possible answers to the system\n(is_anything_unclear)-[:YES]->(ask_question),\n(is_anything_unclear)-[:NO]->(end),\n// Decisions can have multiple arbitrary outcomes\n(is_anything_unclear)-[:MAYBE]->(ask_question)\n'})}),"\n",(0,t.jsx)(n.p,{children:"Let's break down what this program does:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:'(is_anything_unclear:Decision {name:"Find out if there is anything unclear in the Objective", question:"Is the Objective unclear?"})'}),': Creates a Decision Node named "is_anything_unclear." This node checks whether the objective is unclear, asking the question "Is the Objective unclear?".']}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:'(ask_question:Action {name:"Ask question to clarify the objective", tool:"AskUser", prompt:"Pick one question to clarify the Objective"})'}),': Creates an Action Node named "ask_question." If the objective is unclear, this node prompts the system to ask a question to clarify the objective, utilizing the "AskUser" tool.']}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:'(refine_objective:Action {name:"Clarify the given objective", tool:"UpdateObjective", prompt:"The refined Objective"})'}),': Creates another Action Node named "refine_objective." This node represents the action of clarifying the given objective, using the "UpdateObjective" tool.']}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"(start)-[:NEXT]->(is_anything_unclear)"}),': Establishes a relationship between the Start Node and the "is_anything_unclear" Decision Node, indicating the flow of the program.']}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"(ask_question)-[:NEXT]->(refine_objective)"}),': Creates a relationship between the "ask_question" Action Node and the "refine_objective" Action Node, signifying that after asking a question to clarify the objective, the system should proceed to refine the objective.']}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"(refine_objective)-[:NEXT]->(is_anything_unclear)"}),': Establishes a loop by connecting the "refine_objective" Action Node back to the "is_anything_unclear" Decision Node. This loop allows the system to check again if the objective is unclear after attempting to clarify it.']}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"(is_anything_unclear)-[:YES]->(ask_question)"}),': If the decision is "Yes" (the objective is unclear), the program flows to the "ask_question" Action Node to prompt further clarification.']}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"(is_anything_unclear)-[:NO]->(end)"}),': If the decision is "No" (the objective is clear), the program flows to the End Node, concluding the program.']}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"(is_anything_unclear)-[:MAYBE]->(ask_question)"}),': Introduces a "Maybe" outcome for the decision. If the system is uncertain whether the objective is unclear, it will loop back to the "ask_question" Action Node for further clarification.']}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"This program structure enables the system to iteratively ask questions and refine the objective until it is clear."}),"\n",(0,t.jsxs)(n.p,{children:["Now let's use this program to build a simple app, for that, you need to implement a ",(0,t.jsx)(n.code,{children:"main.cypher"})," file that will act as entrypoint for the program."]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-javascript",metastring:'title="main.cypher"',children:'CREATE\n// Nodes declaration\n(start:Control {name:"Start"}),\n(end:Control {name:"End"}),\n(clarify_objective:Program {\n    name:"Clarify the Objective if needed",\n    program:"clarify_objective"}),\n(answer:Action {\n    name:"Answer the Objective",\n    tool:"Speak",\n    prompt:"Please answer the Objective"}),\n// Structure declaration\n(start)-[:NEXT]->(clarify_objective),\n(clarify_objective)-[:NEXT]->(answer),\n(answer)-[:NEXT]->(end)\n'})}),"\n",(0,t.jsx)(n.p,{children:"Let's break down this main program:"}),"\n",(0,t.jsxs)(n.ul,{children:["\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:'(clarify_objective:Program {name:"Clarify the Objective if needed", program:"clarify_objective"})'}),": This line creates a Program Node, that call the program implemented in ",(0,t.jsx)(n.code,{children:"clarify_objective.cypher"}),", after executing this sub-program the program will resume to the next step."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:'(answer:Action {name:"Answer the Objective", tool:"Speak", prompt:"Please answer the Objective"})'}),": This line creates an Action Node that answer the Objective question."]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"(start)-[:NEXT]->(clarify_objective)"}),":"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"(clarify_objective)-[:NEXT]->(answer)"}),":"]}),"\n"]}),"\n",(0,t.jsxs)(n.li,{children:["\n",(0,t.jsxs)(n.p,{children:[(0,t.jsx)(n.code,{children:"(answer)-[:NEXT]->(end)"}),":"]}),"\n"]}),"\n"]}),"\n",(0,t.jsx)(n.p,{children:"Now you can implement almost any prompting mechanism using graphs! Your imagination is the only limit!"})]})}function d(e={}){const{wrapper:n}={...(0,o.a)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(l,{...e})}):l(e)}},1151:(e,n,i)=>{i.d(n,{Z:()=>a,a:()=>s});var t=i(7294);const o={},r=t.createContext(o);function s(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(o):e.components||o:s(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);