"use strict";(self.webpackChunksynalinks_website=self.webpackChunksynalinks_website||[]).push([[434],{414:(e,t,r)=>{r.r(t),r.d(t,{assets:()=>h,contentTitle:()=>i,default:()=>p,frontMatter:()=>o,metadata:()=>s,toc:()=>d});var n=r(4848),a=r(8453);const o={},i="Graph Program Interpreter",s={id:"api/agents/graph-program-interpreter",title:"Graph Program Interpreter",description:"The Graph Program Interpreter serves as the primary agent within the HybridAGI framework. Similar to how a Python interpreter processes a program line by line, this agent interprets a graph program node by node. This approach enables the agent to demonstrate explainable behavior, as it executes only the actions and decisions specified by the graph. The deterministic nature of this behavior is vital for the development of explainable systems and allows developers to improve and correct the agent's behavior without the need for fine-tuning.",source:"@site/docs/api/agents/graph-program-interpreter.md",sourceDirName:"api/agents",slug:"/api/agents/graph-program-interpreter",permalink:"/documentation/docs/api/agents/graph-program-interpreter",draft:!1,unlisted:!1,tags:[],version:"current",frontMatter:{},sidebar:"apiSidebar",previous:{title:"Agents",permalink:"/documentation/docs/category/agents"},next:{title:"Embeddings",permalink:"/documentation/docs/category/embeddings"}},h={},d=[{value:"Usage",id:"usage",level:2}];function m(e){const t={code:"code",h1:"h1",h2:"h2",p:"p",pre:"pre",...(0,a.R)(),...e.components};return(0,n.jsxs)(n.Fragment,{children:[(0,n.jsx)(t.h1,{id:"graph-program-interpreter",children:"Graph Program Interpreter"}),"\n",(0,n.jsx)(t.p,{children:"The Graph Program Interpreter serves as the primary agent within the HybridAGI framework. Similar to how a Python interpreter processes a program line by line, this agent interprets a graph program node by node. This approach enables the agent to demonstrate explainable behavior, as it executes only the actions and decisions specified by the graph. The deterministic nature of this behavior is vital for the development of explainable systems and allows developers to improve and correct the agent's behavior without the need for fine-tuning."}),"\n",(0,n.jsx)(t.p,{children:"In contrast to React agents, which depend heavily on the training of the Language Models (LMs) to manage new tasks, HybridAGI has the ability to direct the agent to act beyond the limits of its data distribution. This capability enables HybridAGI to handle previously unencountered tasks with ease and control."}),"\n",(0,n.jsx)(t.p,{children:"By not permitting the agent system to decide which tool to use at each step, HybridAGI can accommodate an infinite number of tools. This is a significant advantage over React-based agent architectures or agents that rely on function calling. Furthermore, this mechanism allows for the use of smaller LLMs that have not been specifically trained to use function calling or tools."}),"\n",(0,n.jsx)(t.h2,{id:"usage",children:"Usage"}),"\n",(0,n.jsx)(t.pre,{children:(0,n.jsx)(t.code,{className:"language-python",children:'from hybridagi import GraphProgramInterpreter\nfrom hybridagi import ProgramMemory, TraceMemory\nfrom hybridagi import SentenceTransformerEmbeddings\nfrom hybridagi import AgentState\n\n# The embeddings needed for the hybrid vector/graph memories\nembeddings = SentenceTransformerEmbeddings(\n    dim = 384,\n    model_name_or_path = "sentence-transformers/all-MiniLM-L6-v2",\n)\n\n# The program memory is mandatory for the agent system\nprogram_memory = ProgramMemory(\n    index_name = "hybrid_agi",\n    embeddings = embeddings,\n    wipe_on_start = True,\n)\n\n# The trace memory is optional but useful to inspect the behavior of your agent\ntrace_memory = TraceMemory(\n    index_name = "hybrid_agi",\n    embeddings = embeddings,\n    wipe_on_start = True,\n)\n\ntools = [\n    # ...\n    # The tools to use\n]\n\nagent_state = AgentState()\n\ninterpreter = GraphProgramInterpreter(\n    program_memory = program_memory, # The program memory (mandatory)\n    trace_memory = trace_memory, # The trace memory that records every step inside the graph database\n    agent_state = agent_state, # The state of the agent, created if not provided\n    tools = tools, # The tools to use\n    entrypoint = "main", # The entrypoint of the interpreter\n    num_history = 5, # The number of steps to include in the agent context (default is 5)\n    max_iters = 20, # The maximum iterations of the agent (default is 20)\n    add_final_step = True, # Whether or not to add an extra step for the final answer (default to True)\n    commit_decision_steps = True, # Whether or not to include decision steps in the agent context (default is True)\n    commit_program_flow_steps = True, # Whether or not to include the call and end program steps in the context (default is True)\n    return_final_answer = True, # Whether or not to return the agent\'s final answer (default to True)\n    return_program_trace = True, # Whether or not to return the agent trace (default to True)\n    return_chat_history = True, # Whether or not to return the chat history (default to True)\n    verbose = True, # Prints the interpreter steps if True\n)\n\n\n'})})]})}function p(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,n.jsx)(t,{...e,children:(0,n.jsx)(m,{...e})}):m(e)}},8453:(e,t,r)=>{r.d(t,{R:()=>i,x:()=>s});var n=r(6540);const a={},o=n.createContext(a);function i(e){const t=n.useContext(o);return n.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:i(e.components),n.createElement(o.Provider,{value:t},e.children)}}}]);